[{"C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\index.js":"1","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\App.js":"2","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\reportWebVitals.js":"3","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\utils\\sorting.js":"4","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\components\\box.js":"5"},{"size":500,"mtime":499162500000,"results":"6","hashOfConfig":"7"},{"size":4100,"mtime":1607903558816,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":499162500000,"results":"9","hashOfConfig":"7"},{"size":1498,"mtime":1607900992250,"results":"10","hashOfConfig":"7"},{"size":652,"mtime":1607903523706,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1ksbjf3",{"filePath":"15","messages":"16","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"14"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"14"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},"C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\index.js",[],["26","27"],"C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\App.js",["28","29"],"import React, { useRef, useEffect, useState } from 'react';\nimport './App.css';\nimport { Canvas, useFrame } from 'react-three-fiber';\nimport { OrbitControls } from 'drei';\nimport mergeSort from './utils/sorting';\nimport Box from './components/box';\n\nfunction App() {\n  useEffect(() => {\n    loop();\n  }, []);\n\n  const loop = () => {\n    const newArray = []\n    let count = 0;\n    const r = 6;\n    const incr = 0.17;\n    for (let i = 0; i < 6.28; i = i + incr) {\n      for (let j = 0; j < 6.28; j = j + incr) {\n        let x = Math.cos(j) * Math.cos(i) * r;\n        let y = Math.sin(j) * Math.cos(i) * r;\n        let z = Math.sin(i) * r;\n        newArray.push({\n          ID: count,\n          ready: true,\n          position: [x, y, z],\n          color: 'teal'\n        })\n        count++;\n      }\n    }\n    // storing ALL distances between each point in the array for sorting\n    newArray.forEach(element => {\n      const distCollection = []\n      newArray.forEach(point => {\n        const x = (element.position[0] - point.position[0]) * (element.position[0] - point.position[0]);\n        const y = (element.position[1] - point.position[1]) * (element.position[1] - point.position[1]);\n        const z = (element.position[2] - point.position[2]) * (element.position[2] - point.position[2]);\n        const dist = x + y + z\n        // adding 'index' property because the mergeSort method requires both 'value' and 'index'\n        const index = newArray.indexOf(point)\n        distCollection.push({ value: dist, index: index, ID: point.ID })\n      });\n      // sorting by distance, for now, is to assume all clusters are spacially related\n      // but in reality concepts can be related from far away \n      // think 'apple', 'red', 'blood', related but potentially spacially far apart\n      mergeSort(distCollection)\n      element.edges = [\n        distCollection[2].ID,\n        distCollection[3].ID,\n        distCollection[4].ID,\n        distCollection[5].ID,\n        distCollection[6].ID\n      ]\n    });\n    setArray(newArray)\n  }\n  const [array, setArray] = useState([]);\n\n  const handleClick = (e) => {\n    const name = e.object.name;\n    spread(name);\n  }\n\n  const spread = (name) => {\n    const edges = array[name].edges.filter(edge => array[edge].ready);\n    if (edges.length) {\n      const random = Math.floor(Math.random() * edges.length);\n      const edge = edges[random];\n      setTimeout(() => {\n        const array2 = [...array];\n        array2[name].color = 'red';\n        array2[name].ready = false;\n        setArray(array2);\n        setTimeout(() => {\n          array2[name].color = 'blue';\n          setArray(array2);\n          setTimeout(() => {\n            array2[name].color = 'teal';\n            array2[name].ready = true\n            setArray(array2);\n          }, 1200);\n        }, 400);\n        spread(edge)\n      }, 100);\n    } else {\n      const random = Math.floor(Math.random() * 1369)\n      spread(random)\n    }\n  }\n  return (\n    <>\n      <Canvas\n        camera={{ position: [5, 2, 10], fov: 1700 }}\n      >\n        <ambientLight intensity={0.1} />\n        <pointLight position={[-10, 0, -20]} intensity={0.5} />\n        <pointLight position={[0, -10, 0]} intensity={1.5} />\n        <directionalLight\n          position={[0, 10, 0]}\n          intensity={1.5}\n          shadow-mapSize-width={1024}\n          shadow-mapSize-height={1024}\n          shadow-camera-far={50}\n          shadow-camera-left={-10}\n          shadow-camera-right={10}\n          shadow-camera-top={10}\n          shadow-camera-bottom={-10}\n        />\n        {\n          array.length !== 0 ?\n            array.map((position, index) => (\n              <Box\n                handleClick={handleClick}\n                key={index}\n                name={position.ID}\n                edges={position.edges}\n                position={position.position}\n                newColor={\n                  position.ID <= 0 ? 'yellow' :\n                    position.color} />\n            ))\n            : <Box position={[0, 0, 0]} />\n        }\n        <OrbitControls />\n      </Canvas>\n    </>\n  );\n}\n\nexport default App;\n","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\reportWebVitals.js",[],"C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\utils\\sorting.js",["30"],"export default function mergeSort(array) {\r\n  divide(array)\r\n  // console.log(array.length);\r\n  function divide(array) {\r\n    if (array.length < 2) {\r\n      return array;\r\n    } else {\r\n      const half = Math.floor(array.length / 2);\r\n      const left = array.slice(0, half);\r\n      const right = array.slice(half, array.length + 1);\r\n      return merge(divide(left), divide(right))\r\n    }\r\n  }\r\n  function merge(left, right) {\r\n    let buffer = []\r\n    const start = left[0].index;\r\n    const end = right[right.length - 1].index;\r\n    while (left.length !== 0 && right.length !== 0) {\r\n      if (left[0].value < right[0].value) {\r\n        buffer.push(left.shift())\r\n      } else {\r\n        buffer.push(right.shift())\r\n      }\r\n    }\r\n    while (left.length !== 0) {\r\n      buffer.push(left.shift())\r\n    }\r\n    while (right.length !== 0) {\r\n      buffer.push(right.shift())\r\n    }\r\n    for (let i = start, j = 0; i < end, j < buffer.length; j++, i++) {\r\n      // let colorDiv = document.getElementById(`${buffer[j].index}`)\r\n      // let barDiv = document.getElementById(`${i}`);\r\n      // let height = buffer[j].value;\r\n      buffer[j].index = i;\r\n      // setTimeout(() => {\r\n      //   colorDiv.style.backgroundColor = 'magenta'\r\n      //   setTimeout(() => {\r\n      //     colorDiv.style.backgroundColor = 'aqua'\r\n      //     barDiv.style.height = `${height}px`;\r\n      //   }, 50);\r\n      // }, j * 50);\r\n    }\r\n    array.splice(start, buffer.length, ...buffer);\r\n    return buffer;\r\n  }\r\n}","C:\\Users\\Dughes\\desktop\\homework\\train_of_thought\\thought\\src\\components\\box.js",["31"],"import React, { useRef } from 'react';\r\nimport { useFrame } from 'react-three-fiber';\r\n\r\nfunction Box({ position, newColor, edges, name, handleClick }) {\r\n  const mesh = useRef(null)\r\n  // useFrame(() => {\r\n  //   mesh.current.rotation.x = mesh.current.rotation.y = 0.01;\r\n  // })\r\n\r\n  return (\r\n    <mesh\r\n      position={position}\r\n      name={name}\r\n      ref={mesh}\r\n      userData={{ edges: edges, position: position, color: newColor }}\r\n      onClick={handleClick} >\r\n      <sphereBufferGeometry attach='geometry' args={[0.2, 500]} />\r\n      <meshStandardMaterial attach='material' color={newColor} />\r\n    </mesh>\r\n  )\r\n}\r\n\r\nexport default Box\r\n",{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","severity":1,"message":"37","line":1,"column":17,"nodeType":"38","messageId":"39","endLine":1,"endColumn":23},{"ruleId":"36","severity":1,"message":"40","line":3,"column":18,"nodeType":"38","messageId":"39","endLine":3,"endColumn":26},{"ruleId":"41","severity":1,"message":"42","line":31,"column":39,"nodeType":"43","messageId":"44","endLine":31,"endColumn":40},{"ruleId":"36","severity":1,"message":"40","line":2,"column":10,"nodeType":"38","messageId":"39","endLine":2,"endColumn":18},"no-native-reassign",["45"],"no-negated-in-lhs",["46"],"no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","'useFrame' is defined but never used.","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression","no-global-assign","no-unsafe-negation"]